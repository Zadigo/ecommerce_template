import datetime
from itertools import filterfalse

from django import forms
from django.contrib.auth import get_user_model
from django.core import exceptions
from django.db import transaction
from django.forms import fields, widgets
from django.utils.translation import gettext_lazy as _

from accounts.utils import get_user_profile_model
from dashboard import models as dashboard_models
from dashboard import widgets as custom_widgets
from shop import choices, models, utilities, validators


class FormMixin:
    """
    A special mixin created to handle data of m2m fields
    generated by the dynamic fields with Vue JS
    """
    @staticmethod
    def _check_has_same_lengths(*lists):
        """
        Checks whether the incoming arrays
        are all of the same length
        """
        lengths = []
        for item in lists:
            lengths.append(len(item))
        truth_array = []
        count_of_values_test = len(lengths)

        for i in range(count_of_values_test):
            t = i + 1
            if t == count_of_values_test:
                break
            truth_array.append(lengths[t] == lengths[t - 1])
        return all(truth_array)

    @staticmethod
    def _check_if_none(items, index, default=None, constraint=False):
        """
        Checks if an item is none

        Parameters
        ----------

            - items: the actual list of items
            - index: the index of the item to check
            - default: default value if the field is actually none
            - against: 
        """
        try:
            item = items[index]
        except KeyError:
            if constraint and default == None:
                raise exceptions.ValidationError("La valeur ne peut pas être nul")
            item = default
        
        return item

    @staticmethod
    def _are_all_image_links(links):
        def conditions(x): return all([
            x.startswith('http'),
            any([
                x.endswith('.jpg'),
                x.endswith('.jpeg'),
                x.endswith('.png')
            ])
        ])
        false_values = list(filterfalse(conditions, links))
        return False if false_values else True, false_values

    def _create_new(self, instance, 
                    m2m_field, fields_names: list, 
                    model_to_update: type, model_fields: list,
                    should_not_be_none: list=[], defaults:list=[], old_items=None):
        """
        Creates new items in the database using the m2m
        relationship

        Parameters
        -----------

            - unsaved_instance: the current db instance
            - m2m_field: is the name of the m2m field to set
            - fields_names: corresponds to the names of the fields coming from the form
            - model: model in which to create the items
            - model_fields: fields in the model to use for creating the item in the database
        """
        # We will use the first item in the list as our
        # benchmark for testing if we should continue
        # of not with the saving process
        base_field_name_values = self.data.getlist(fields_names[0], [])
        
        if base_field_name_values:
            field_values = [
                self.data.getlist(field, [])
                for field in fields_names
            ]

            has_same_lengths = self._check_has_same_lengths(*field_values)

            if has_same_lengths:
                list_of_models = [model_to_update for _ in range(len(base_field_name_values))]

                transposed_items = []

                # Transpose to -> [field, [values]]
                for i, values in enumerate(field_values):
                    transposed_items.append([model_fields[i], values])
                
                final_dict = {}

                for i, model in enumerate(list_of_models):
                    # -> [key, [value1, value2, ...]]
                    for item in transposed_items:
                        key = item[0]
                        value = item[1][i]
                        final_dict.update({key: value})
                    list_of_models[i] = model(**final_dict)
                    final_dict = {}
    
                try:
                    with transaction.atomic():
                        new_items = model_to_update.objects.bulk_create(list_of_models)
                except:
                    return instance
                else:
                    instance.save()
                    m2m_relation = getattr(instance, m2m_field)
                    if old_items:
                        new_items = list(old_items) + new_items
                    m2m_relation.set(new_items)
                    return instance, new_items
        return instance

    def _update_old(self, instance, primary_key_name, form_fields: list,
                    model_fields: list, model_to_update: type, cannot_be_none: str=None, 
                    default_if_none=None, save=False):
        """
        Updates old items in the database using the m2m relationship

        Parameters
        ----------

            - primary_key_name: name of the field to get the primary keys from
        """
        incoming_values = [
            self.data.getlist(field, [])
                for field in form_fields
        ]
        
        has_same_lengths = self._check_has_same_lengths(*incoming_values)

        if has_same_lengths:
            incoming_primary_keys = self.data.getlist(primary_key_name, [])
            if incoming_primary_keys:
                queryset = model_to_update.objects.filter(id__in=incoming_primary_keys)

                if queryset.exists():
                    transposed_items = []

                    # Transpose to -> [field, [values]]
                    for i, values in enumerate(incoming_values):
                        transposed_items.append([model_fields[i], values])
                    
                    for i, item in enumerate(queryset):
                        for values in transposed_items:
                            setattr(item, values[0], values[1][i])

                    model_to_update.objects.bulk_update(queryset, model_fields)
                    return instance, queryset
        return instance, None

    def _automatic_collections_check(self):
        # Now, check that for automatic collections
        # and see if the product can be included
        # automatic_collections = models.ProductCollection.objects.filter(automatic=True)
        pass


class ProductForm(forms.ModelForm):
    class Meta:
        model = models.Product
        localized_fields = ('price_valid_until',)
        exclude = ['images', 'variant', 'slug', 'last_modified', 'created_on']
        widgets = {
            'name': custom_widgets.TextInput(attrs={'placeholder': 'Nom du produit'}),
            'description': forms.widgets.Textarea(attrs={'class': 'form-control'}),
            'gender': widgets.Select(attrs={'class': 'form-control'}),

            'sku': custom_widgets.TextInput(attrs={'placeholder': 'SKU'}),
            'reference': custom_widgets.TextInput(attrs={'placeholder': 'Référence'}),
            
            'price_ht': custom_widgets.NumberInput(attrs={'placeholder': 'Prix Hors Taxe', 'min': '0', 'step': 'any'}),
            'price_valid_until': custom_widgets.DateInput(),
            'discount_pct': custom_widgets.NumberInput(attrs={'class': 'form-control', 'placeholder': 'Nombre en %', 'min': '5'}),
            'quantity': custom_widgets.NumberInput(attrs={'class': 'form-control', 'step': '5', 'min': '0'}),
            
            'collection': widgets.Select(attrs={'class': 'form-control'}),
            'google_category': widgets.Select(attrs={'class': 'form-control'}),

            'in_stock': widgets.CheckboxInput(attrs={'class': 'custom-control-input'}),
            'our_favorite': widgets.CheckboxInput(attrs={'class': 'custom-control-input'}),
            'discounted': widgets.CheckboxInput(attrs={'class': 'custom-control-input'}),
            'active': widgets.CheckboxInput(attrs={'class': 'custom-control-input'}),
            'private': widgets.CheckboxInput(attrs={'class': 'custom-control-input'}),

            'to_be_published_on': custom_widgets.DateInput()
        }


class UpdateProductForm(FormMixin, ProductForm):
    def save(self):
        """
        This overidding of the save function accounts for permitting
        the user to be able to dynamically add and update sizes using
        our custom Vue JS dynamic input fields on the form.

        Description
        -----------

            - When the user does not add a new input field, no size is created
              since `new-size-name` would not be defined

            - On the other hand, if `new-size-name` is defined, new variants
              fields are created and attached to the product
        """
        product = super().save(commit=False)
        self._update_old_sizes(product)
        # images = self._update_old_images()
        # self._create_new_images(product, old_items=images)

        _, old_items = self._update_old(
            product,
            'image-key',
            ['image-url', 'image-name', 'image-variant'],
            ['url', 'name', 'variant'],
            models.Image
        )

        self._create_new(
            product,
            'images',
            ['new-image-url', 'new-image-name', 'new-image-variant'],
            models.Image,
            ['url', 'name', 'variant'],
            old_items=old_items
        )
        
        product.save()
        return self.instance

    def _update_old_sizes(self, product):
        product_has_size = self.data.get('has-size')

        if product_has_size == 'on':
            existing_size_names = self.data.getlist('size-name')
            new_size_names = self.data.getlist('new-size-name', [])

            existing_verbose_names = self.data.getlist('verbose-name', [])
            new_verbose_names = self.data.getlist('new-verbose-name')
            # These are keys that are inititally issued
            # from the database to frontend
            incoming_primary_keys = self.data.getlist('keys')

            product_variants = product.variant.filter(id__in=incoming_primary_keys)
            if product_variants.exists():
                for index, variant in enumerate(product_variants):
                    variant.name = existing_size_names[index]
                    variant.verbose_name = existing_verbose_names[index]
                models.Variant.objects.bulk_update(product_variants, ['name', 'verbose_name'])

            # This section is exclusive for creating
            # new size fiels in the database

            items = []
            if new_size_names:
                for i in range(len(new_size_names)):
                    try:
                        name = new_size_names[i]
                    except KeyError:
                        name = None
                    
                    try:
                        verbose_name = new_verbose_names[i]
                    except:
                        verbose_name = None

                    if name and verbose_name:
                        items.append(models.Variant(name=name, verbose_name=verbose_name))
                    
                    if name and not verbose_name:
                        items.append(models.Variant(name=name))

                if items:
                    try:
                        with transaction.atomic():
                            new_variants = models.Variant.objects.bulk_create(items)
                    except:
                        return self.instance
                    else:
                        new_variants = list(product_variants) + new_variants
                        product.variant.set(new_variants)
                    
    
class CreateProductForm(FormMixin, ProductForm):
    """
    This overidding of the save function accounts for permitting
    the user to be able to dynamically add and update sizes using
    our custom Vue JS dynamic input fields on the form.

    Description
    -----------

        Creates all the necessary variants once the producth as been
        created
    """

    def save(self):
        product = super().save(commit=False)
        product_has_size = self.data.get('has-size')
        if product_has_size == 'on':
            items = []

            new_size_names = self.data.getlist('new-size-name', [])
            new_verbose_names = self.data.getlist('new-verbose-name')

            if new_size_names:
                for i in range(len(new_size_names)):
                    try:
                        name = new_size_names[i]
                    except KeyError:
                        name = None
                    
                    try:
                        verbose_name = new_verbose_names[i]
                    except:
                        verbose_name = None

                    if name and verbose_name:
                        items.append(models.Variant(name=name, verbose_name=verbose_name))
                    
                    if name and not verbose_name:
                        items.append(models.Variant(name=name))

                if items:
                    new_variants = models.Variant.objects.bulk_create(items)

                product.save()
                product.variant.set(new_variants)
                return self.instance

        # product.save()

        self._create_new(
            product,
            'images',
            ['new-image-url', 'new-image-name', 'new-image-variant'],
            models.Image,
            ['url', 'name', 'variant']
        )
        return self.instance


class DiscountForm(forms.ModelForm):
    class Meta:
        model = models.Discount
        fields = ['code', 'value_type', 'value', 'collection', 'on_entire_order',\
         'minimum_purchase', 'minimum_quantity', 'usage_limit', 'start_date', 'end_date']

        widgets = {
            'code': custom_widgets.TextInput(attrs={'placeholder': 'Code'}),
            'value_type': widgets.Select(attrs={'class': 'form-control'}),

            'value': custom_widgets.NumberInput(),
            'collection': widgets.Select(attrs={'class': 'form-control'}),

            'on_entire_order': widgets.CheckboxInput(),
            
            'minimum_purchase': custom_widgets.NumberInput(),
            'minimum_quantity': custom_widgets.NumberInput(),

            'usage_limit': custom_widgets.NumberInput(),

            'start_date': custom_widgets.DateInput(),
            'end_date': custom_widgets.DateInput(),
        }


class CollectionForm(forms.ModelForm):
    class Meta:
        model = models.ProductCollection
        fields = ['name', 'presentation_text', 'google_description', 'show_presentation']

        widgets = {
            'name': custom_widgets.TextInput(attrs={'placeholder': 'Nom de la collection'}),
            'presentation_text': forms.widgets.Textarea(attrs={'class': 'form-control'}),
        }

    # def save(self):
    #     collection = super().save(commit=False)
    #     is_automatic_collection = self.data.get('automatic', False)
    #     if is_automatic_collection:
    #         respect_all_conditions = self.data.get('respect_all_conditions', True)
    #         if respect_all_conditions == 'all':
    #             respect_all_conditions = True
    #         else:
    #             respect_all_conditions = False

    #         first_conditions = self.data.getlist('condition1')
    #         second_conditions = self.data.getlist('condition2')
    #         values_to_test = self.data.getlist('value')

    #         items = []
    #         for index, value in enumerate(values_to_test):
    #             if value:
    #                 items.append(
    #                     models.AutomaticCollectionCriteria(
    #                         reference=utilities.create_reference(append_prefix=False),
    #                         condition=choices.SecondConditionsChoices.choices[int(second_conditions[index])],
    #                         value=value
    #                     )
    #                 )

    #         with transaction.atomic():
    #             models.AutomaticCollectionCriteria.objects.bulk_create(items)
    #     collection.save()


class CustomerForm(forms.ModelForm):
    class Meta:
        model = get_user_model()
        fields = ['name', 'surname', 'email']

        widgets = {
            'name': custom_widgets.TextInput(attrs={'placeholder': 'Nom'}),
        }


class CustomerOrderForm(forms.ModelForm):
    class Meta:
        model = models.CustomerOrder
        fields = ['accepted', 'shipped',
                  'completed', 'refund', 'tracking_number']

        widgets = {
            'accepted': custom_widgets.CheckBoxInput(),
            'completed': custom_widgets.CheckBoxInput(),
            'refund': custom_widgets.CheckBoxInput(),
            'shipped': custom_widgets.CheckBoxInput(),
            'delivery': custom_widgets.TextInput(),
            'tracking_number': custom_widgets.TextInput(),
        }


class ImageForm(forms.ModelForm): 
    class Meta:
        model = models.Image
        fields = ['name', 'url', 'variant', 'main_image']
        widgets = {
            'name': custom_widgets.TextInput(attrs={'placeholder': 'Name'}),
            'url': custom_widgets.TextInput(attrs={'placeholder': 'Url'}),
            'variant': custom_widgets.TextInput(attrs={'placeholder': 'Variant'}),
            'main_image': custom_widgets.CheckBoxInput()
        }


class DashboardSettingsForm(forms.ModelForm):
    class Meta:
        model = dashboard_models.DashboardSetting
        fields = ['name', 'contact_email', 'customer_care_email',
                  'automatic_archive', 'allow_coupons', 'legal_name', 'telephone']
        widgets = {
            'name': custom_widgets.TextInput(),
            'contact_email': custom_widgets.EmailInput(),
            'customer_care_email': custom_widgets.EmailInput(),
            'automatic_archive': custom_widgets.CheckBoxInput(),
            'legal_name': custom_widgets.TextInput(),
            'telephone': custom_widgets.TextInput(),
        }
